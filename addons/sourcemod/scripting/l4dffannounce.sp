/* Plugin Template generated by Pawn Studio */

#include <sourcemod>
#include <sdktools>

public Plugin:myinfo = 
{
	name = "L4D FF Announce Plugin",
	author = "Frustian, dustin",
	description = "Adds Friendly Fire Announcements",
	version = "1.5",
	url = ""
}

#define MAX_QUERY_LENGTH		4096

//Various global variables
new DamageCache[MAXPLAYERS+1][MAXPLAYERS+1]; //Used to temporarily store Friendly Fire Damage between teammates
new Handle:FFTimer[MAXPLAYERS+1]; //Used to be able to disable the FF timer when they do more FF
new bool:FFActive[MAXPLAYERS+1]; //Stores whether players are in a state of friendly firing teammates
new bool:g_bAnnounceActive[MAXPLAYERS+1];
new Handle:directorready;
new g_iTopCooldown[MAXPLAYERS+1];

Database g_hDatabase;

ConVar convar_Database;
ConVar convar_Table_ffannounce;

/*
	TODO

	* see if deleting datapack is necessary. From documentation: The datapack is automatically freed when the timer ends.
*/

public OnPluginStart()
{
	convar_Database = CreateConVar("sm_l4dffannounce_database", "l4dffannounce", "Database entry to use in the database config.");
	convar_Table_ffannounce = CreateConVar("sm_l4dffannounce_table_name", "survival_ffannounce", "Table name for !ffannounce command");

	CreateConVar("l4d_ff_announce_version", "1.4", "FF announce Version", FCVAR_SPONLY|FCVAR_NOTIFY);
	HookEvent("player_hurt_concise", Event_HurtConcise, EventHookMode_Post);
	directorready = FindConVar("director_ready_duration");
	
	RegConsoleCmd("sm_ffannounce", Command_ToggleAnnouncements);
	RegConsoleCmd("sm_ffannouncer", Command_ToggleAnnouncements);
}

public Action:Event_HurtConcise(Handle:event, const String:name[], bool:dontBroadcast)
{
	new attacker = GetEventInt(event, "attackerentid");
	new victim = GetClientOfUserId(GetEventInt(event, "userid"));
	
	if (!GetConVarInt(directorready) || attacker > MaxClients || attacker < 1 || !IsClientInGame(attacker) || IsFakeClient(attacker) || GetClientTeam(attacker) != 2 || !IsClientInGame(victim) || GetClientTeam(victim) != 2)
	{
		return;  //if director_ready_duration is 0, it usually means that the game is in a ready up state like downtown1's ready up mod.  This allows me to disable the FF messages in ready up.
	}
	
	new damage = GetEventInt(event, "dmg_health");
	if (FFActive[attacker])  //If the player is already friendly firing teammates, resets the announce timer and adds to the damage
	{
		new Handle:pack;
		DamageCache[attacker][victim] += damage;
		KillTimer(FFTimer[attacker]);
		FFTimer[attacker] = CreateDataTimer(1.0, AnnounceFF, pack);
		WritePackCell(pack,attacker);
	}
	else //If it's the first friendly fire by that player, it will start the announce timer and store the damage done.
	{
		DamageCache[attacker][victim] = damage;
		new Handle:pack;
		FFActive[attacker] = true;
		FFTimer[attacker] = CreateDataTimer(1.0, AnnounceFF, pack);
		WritePackCell(pack,attacker);
		for (new i = 1; i < 19; i++)
		{
			if (i != attacker && i != victim)
			{
				DamageCache[attacker][i] = 0;
			}
		}
	}
}
public Action:AnnounceFF(Handle:timer, Handle:pack) //Called if the attacker did not friendly fire recently, and announces all FF they did
{
	decl String:victim[128];
	decl String:attacker[128];
	ResetPack(pack);
	new attackerc = ReadPackCell(pack);
	FFActive[attackerc] = false;
	
	if (IsClientInGame(attackerc) && !IsFakeClient(attackerc))
	{
		GetClientName(attackerc, attacker, sizeof(attacker));
	}
	else
		attacker = "Disconnected Player";
	
	for (new i = 1; i < MaxClients; i++)
	{
		if (DamageCache[attackerc][i] != 0 && attackerc != i)
		{
			if (IsClientInGame(i) && IsClientConnected(i))
			{
				GetClientName(i, victim, sizeof(victim));
				
				if (g_bAnnounceActive[attackerc] && IsClientInGame(attackerc) && !IsFakeClient(attackerc))
				{
					PrintToChat(attackerc, "\x01[SM] You did \x04%d\x01 friendly fire damage to \x03%s",DamageCache[attackerc][i],victim);
				}
				
				if (g_bAnnounceActive[i] && IsClientInGame(i) && !IsFakeClient(i))
				{
					PrintToChat(i, "\x01[SM] \x03%s\x01 did \x04%d\x01 friendly fire damage to you", attacker, DamageCache[attackerc][i]);
				}
			}
			DamageCache[attackerc][i] = 0;
		}
	}
}

/*********************************************************************************************************
	DATABASE LOGIC
**********************************************************************************************************/

public void OnConfigsExecuted()
{
	if (g_hDatabase == null)
	{
		char sDatabase[256];
		convar_Database.GetString(sDatabase, sizeof(sDatabase));
		
		Database.Connect(OnSQLConnect, strlen(sDatabase) > 0 ? sDatabase : "default");
	}
}

public void OnSQLConnect(Database db, const char[] error, any data)
{
	if (db == null)
		ThrowError("Error connecting to database: %s", error);

	//Double check that we don't already have a connection.
	if (g_hDatabase != null)
	{
		delete db;
		return;
	}

	g_hDatabase = db;
	
	char sQuery[MAX_QUERY_LENGTH];
	char sTable[64];
	convar_Table_ffannounce.GetString(sTable, sizeof(sTable));
	
	FormatEx(sQuery, sizeof(sQuery), "CREATE TABLE IF NOT EXISTS `%s` (`id` int(11) NOT NULL AUTO_INCREMENT, `steam_id` varchar(24) NOT NULL DEFAULT '', enabled BOOLEAN NOT NULL DEFAULT '0', PRIMARY KEY(id));", sTable);
	g_hDatabase.Query(DB_tableCreated, sQuery);
}

void DB_tableCreated(Database db, DBResultSet results, const char[] error, any data)
{
	if (results == null)
	{
		LogError("Error creating DB table: %s", error);
	}
}

public Action Command_ToggleAnnouncements(int client, int args)
{
	int time = GetTime();
	
	if (g_iTopCooldown[client] != -1 && g_iTopCooldown[client] > time)
	{
		ReplyToCommand(client, "[SM] Please wait to use this command.");
		return Plugin_Handled;
	}
	
	g_iTopCooldown[client] = time + 4;
	
	if (!client || client > MaxClients)
	{
		ReplyToCommand(client, "[SM] for in-game use only.");
		return Plugin_Handled;
	}
	
	char sSteamID[24], sTable[64], sQuery[MAX_QUERY_LENGTH];
	convar_Table_ffannounce.GetString(sTable, sizeof(sTable));
	
	if (!GetClientAuthId(client, AuthId_SteamID64, sSteamID, sizeof(sSteamID)))
	{
		ReplyToCommand(client, "[SM] Steam Servers down - can't retrieve your steam ID. Try again later.");
		return Plugin_Handled;
	}
	
	FormatEx(sQuery, sizeof(sQuery), "UPDATE `%s` SET `enabled` = NOT `enabled` WHERE steam_id = '%s';", sTable, sSteamID);
	g_hDatabase.Query(DBQuery_Change_FF_Status, sQuery, GetClientUserId(client));

	return Plugin_Handled;
}

public void DBQuery_Change_FF_Status(Database db, DBResultSet results, const char[] error, any data)
{
	// results will equal null because we're simply updating the client's status and not retrieving any data
	
	int client = GetClientOfUserId(data);
	
	if (!client || !IsClientInGame(client))
	{
		return;
	}
	
	// rather not send another DB query so do it this way instead
	OnClientPutInServer(client);
	CreateTimer(0.5, Timer_RankPrintoutMsg, GetClientUserId(client));
}

public Action Timer_RankPrintoutMsg(Handle timer, any data)
{
	int client = GetClientOfUserId(data);
	
	if (client && IsClientInGame(client))
	{
		PrintToChat(client, "\x01[SM] FF announcer toggled \x04%s", g_bAnnounceActive[client] ? "on" : "off");
	}
}

public void OnClientPutInServer(int client)
{
	if (IsFakeClient(client))
		return;
	
	g_iTopCooldown[client] = -1;

	// query if steam ID found in leaderboard DB
	char sSteamID[64], sTableRank[64], sQuery[MAX_QUERY_LENGTH];
	convar_Table_ffannounce.GetString(sTableRank, sizeof(sTableRank));
	
	if (!GetClientAuthId(client, AuthId_SteamID64, sSteamID, sizeof(sSteamID)))
	{
		// Steam DB down
		g_bAnnounceActive[client] = false;
		return;
	}
	
	// survival_leaderboard_lb
	FormatEx(sQuery, sizeof(sQuery), "SELECT * FROM `%s` WHERE steam_id = '%s';", sTableRank, sSteamID);
	g_hDatabase.Query(DBQuery_FF_Status, sQuery, GetClientUserId(client));
}

public void DBQuery_FF_Status(Database db, DBResultSet results, const char[] error, any data)
{
	int client = GetClientOfUserId(data);
	
	if (results == null)
		ThrowError("Error getting client's ff status results: %s", error);
	
	if (results.FetchRow())
	{	
		int field = -1;
		int istatus;
		
		if (SQL_FieldNameToNum(results, "enabled", field) && field != -1)
		{
			istatus = results.FetchInt(field);
			g_bAnnounceActive[client] = view_as<bool>(istatus);
		}
	}
	else
	{
		Initialize_FFStatus(client);
	}
}

void Initialize_FFStatus(int client)
{
	if (!client)
		return;
	
	if (!IsClientInGame(client))
		return;
	
	g_bAnnounceActive[client] = false;
	
	char sSteamID[56], sTableRank[64], sQuery[MAX_QUERY_LENGTH];
	if (!GetClientAuthId(client, AuthId_SteamID64, sSteamID, sizeof(sSteamID)))
	{
		return;
	}
	
	convar_Table_ffannounce.GetString(sTableRank, sizeof(sTableRank));
	
	Format(sQuery, sizeof(sQuery), "INSERT INTO `%s` (steam_id, enabled) VALUES ('%s', '%i');", sTableRank, sSteamID, 0);
	
	g_hDatabase.Query(DBQuery_OnInitialize_FFStatus, sQuery);
}

public void DBQuery_OnInitialize_FFStatus(Database db, DBResultSet results, const char[] error, any data)
{
	if (results == null)
		ThrowError("Error initializing client's leaderboard status: %s", error);
}